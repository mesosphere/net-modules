// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#ifndef PROTOBUF_interface_2eproto__INCLUDED
#define PROTOBUF_interface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace network_isolator {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_interface_2eproto();
void protobuf_AssignDesc_interface_2eproto();
void protobuf_ShutdownFile_interface_2eproto();

class IPAMRequestIPMessage;
class IPAMRequestIPMessage_Args;
class IPAMReserveIPMessage;
class IPAMReserveIPMessage_Args;
class IPAMReleaseIPMessage;
class IPAMReleaseIPMessage_Args;
class IPAMResponse;
class IsolatorIsolateMessage;
class IsolatorIsolateMessage_Args;
class IsolatorCleanupMessage;
class IsolatorCleanupMessage_Args;
class IsolatorMessage;
class IsolatorMessage_Args;
class IsolatorResponse;

// ===================================================================

class IPAMRequestIPMessage_Args : public ::google::protobuf::Message {
 public:
  IPAMRequestIPMessage_Args();
  virtual ~IPAMRequestIPMessage_Args();

  IPAMRequestIPMessage_Args(const IPAMRequestIPMessage_Args& from);

  inline IPAMRequestIPMessage_Args& operator=(const IPAMRequestIPMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMRequestIPMessage_Args& default_instance();

  void Swap(IPAMRequestIPMessage_Args* other);

  // implements Message ----------------------------------------------

  IPAMRequestIPMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMRequestIPMessage_Args& from);
  void MergeFrom(const IPAMRequestIPMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required int32 num_ipv4 = 2 [default = 0];
  inline bool has_num_ipv4() const;
  inline void clear_num_ipv4();
  static const int kNumIpv4FieldNumber = 2;
  inline ::google::protobuf::int32 num_ipv4() const;
  inline void set_num_ipv4(::google::protobuf::int32 value);

  // required int32 num_ipv6 = 3 [default = 0];
  inline bool has_num_ipv6() const;
  inline void clear_num_ipv6();
  static const int kNumIpv6FieldNumber = 3;
  inline ::google::protobuf::int32 num_ipv6() const;
  inline void set_num_ipv6(::google::protobuf::int32 value);

  // required string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // repeated string netgroups = 5;
  inline int netgroups_size() const;
  inline void clear_netgroups();
  static const int kNetgroupsFieldNumber = 5;
  inline const ::std::string& netgroups(int index) const;
  inline ::std::string* mutable_netgroups(int index);
  inline void set_netgroups(int index, const ::std::string& value);
  inline void set_netgroups(int index, const char* value);
  inline void set_netgroups(int index, const char* value, size_t size);
  inline ::std::string* add_netgroups();
  inline void add_netgroups(const ::std::string& value);
  inline void add_netgroups(const char* value);
  inline void add_netgroups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& netgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_netgroups();

  // optional .mesos.Labels labels = 6;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 6;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMRequestIPMessage.Args)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_num_ipv4();
  inline void clear_has_num_ipv4();
  inline void set_has_num_ipv6();
  inline void clear_has_num_ipv6();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::int32 num_ipv4_;
  ::google::protobuf::int32 num_ipv6_;
  ::std::string* uid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> netgroups_;
  ::mesos::Labels* labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMRequestIPMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IPAMRequestIPMessage : public ::google::protobuf::Message {
 public:
  IPAMRequestIPMessage();
  virtual ~IPAMRequestIPMessage();

  IPAMRequestIPMessage(const IPAMRequestIPMessage& from);

  inline IPAMRequestIPMessage& operator=(const IPAMRequestIPMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMRequestIPMessage& default_instance();

  void Swap(IPAMRequestIPMessage* other);

  // implements Message ----------------------------------------------

  IPAMRequestIPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMRequestIPMessage& from);
  void MergeFrom(const IPAMRequestIPMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IPAMRequestIPMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "allocate"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IPAMRequestIPMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IPAMRequestIPMessage_Args& args() const;
  inline ::network_isolator::IPAMRequestIPMessage_Args* mutable_args();
  inline ::network_isolator::IPAMRequestIPMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IPAMRequestIPMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMRequestIPMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IPAMRequestIPMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMRequestIPMessage* default_instance_;
};
// -------------------------------------------------------------------

class IPAMReserveIPMessage_Args : public ::google::protobuf::Message {
 public:
  IPAMReserveIPMessage_Args();
  virtual ~IPAMReserveIPMessage_Args();

  IPAMReserveIPMessage_Args(const IPAMReserveIPMessage_Args& from);

  inline IPAMReserveIPMessage_Args& operator=(const IPAMReserveIPMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMReserveIPMessage_Args& default_instance();

  void Swap(IPAMReserveIPMessage_Args* other);

  // implements Message ----------------------------------------------

  IPAMReserveIPMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMReserveIPMessage_Args& from);
  void MergeFrom(const IPAMReserveIPMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // repeated string ipv4_addrs = 2;
  inline int ipv4_addrs_size() const;
  inline void clear_ipv4_addrs();
  static const int kIpv4AddrsFieldNumber = 2;
  inline const ::std::string& ipv4_addrs(int index) const;
  inline ::std::string* mutable_ipv4_addrs(int index);
  inline void set_ipv4_addrs(int index, const ::std::string& value);
  inline void set_ipv4_addrs(int index, const char* value);
  inline void set_ipv4_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv4_addrs();
  inline void add_ipv4_addrs(const ::std::string& value);
  inline void add_ipv4_addrs(const char* value);
  inline void add_ipv4_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv4_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv4_addrs();

  // repeated string ipv6_addrs = 3;
  inline int ipv6_addrs_size() const;
  inline void clear_ipv6_addrs();
  static const int kIpv6AddrsFieldNumber = 3;
  inline const ::std::string& ipv6_addrs(int index) const;
  inline ::std::string* mutable_ipv6_addrs(int index);
  inline void set_ipv6_addrs(int index, const ::std::string& value);
  inline void set_ipv6_addrs(int index, const char* value);
  inline void set_ipv6_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv6_addrs();
  inline void add_ipv6_addrs(const ::std::string& value);
  inline void add_ipv6_addrs(const char* value);
  inline void add_ipv6_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv6_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv6_addrs();

  // required string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // repeated string netgroups = 5;
  inline int netgroups_size() const;
  inline void clear_netgroups();
  static const int kNetgroupsFieldNumber = 5;
  inline const ::std::string& netgroups(int index) const;
  inline ::std::string* mutable_netgroups(int index);
  inline void set_netgroups(int index, const ::std::string& value);
  inline void set_netgroups(int index, const char* value);
  inline void set_netgroups(int index, const char* value, size_t size);
  inline ::std::string* add_netgroups();
  inline void add_netgroups(const ::std::string& value);
  inline void add_netgroups(const char* value);
  inline void add_netgroups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& netgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_netgroups();

  // optional .mesos.Labels labels = 6;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 6;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMReserveIPMessage.Args)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv4_addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv6_addrs_;
  ::std::string* uid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> netgroups_;
  ::mesos::Labels* labels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMReserveIPMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IPAMReserveIPMessage : public ::google::protobuf::Message {
 public:
  IPAMReserveIPMessage();
  virtual ~IPAMReserveIPMessage();

  IPAMReserveIPMessage(const IPAMReserveIPMessage& from);

  inline IPAMReserveIPMessage& operator=(const IPAMReserveIPMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMReserveIPMessage& default_instance();

  void Swap(IPAMReserveIPMessage* other);

  // implements Message ----------------------------------------------

  IPAMReserveIPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMReserveIPMessage& from);
  void MergeFrom(const IPAMReserveIPMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IPAMReserveIPMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "reserve"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IPAMReserveIPMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IPAMReserveIPMessage_Args& args() const;
  inline ::network_isolator::IPAMReserveIPMessage_Args* mutable_args();
  inline ::network_isolator::IPAMReserveIPMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IPAMReserveIPMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMReserveIPMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IPAMReserveIPMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMReserveIPMessage* default_instance_;
};
// -------------------------------------------------------------------

class IPAMReleaseIPMessage_Args : public ::google::protobuf::Message {
 public:
  IPAMReleaseIPMessage_Args();
  virtual ~IPAMReleaseIPMessage_Args();

  IPAMReleaseIPMessage_Args(const IPAMReleaseIPMessage_Args& from);

  inline IPAMReleaseIPMessage_Args& operator=(const IPAMReleaseIPMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMReleaseIPMessage_Args& default_instance();

  void Swap(IPAMReleaseIPMessage_Args* other);

  // implements Message ----------------------------------------------

  IPAMReleaseIPMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMReleaseIPMessage_Args& from);
  void MergeFrom(const IPAMReleaseIPMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ips = 1;
  inline int ips_size() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 1;
  inline const ::std::string& ips(int index) const;
  inline ::std::string* mutable_ips(int index);
  inline void set_ips(int index, const ::std::string& value);
  inline void set_ips(int index, const char* value);
  inline void set_ips(int index, const char* value, size_t size);
  inline ::std::string* add_ips();
  inline void add_ips(const ::std::string& value);
  inline void add_ips(const char* value);
  inline void add_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();

  // optional string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMReleaseIPMessage.Args)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMReleaseIPMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IPAMReleaseIPMessage : public ::google::protobuf::Message {
 public:
  IPAMReleaseIPMessage();
  virtual ~IPAMReleaseIPMessage();

  IPAMReleaseIPMessage(const IPAMReleaseIPMessage& from);

  inline IPAMReleaseIPMessage& operator=(const IPAMReleaseIPMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMReleaseIPMessage& default_instance();

  void Swap(IPAMReleaseIPMessage* other);

  // implements Message ----------------------------------------------

  IPAMReleaseIPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMReleaseIPMessage& from);
  void MergeFrom(const IPAMReleaseIPMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IPAMReleaseIPMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "release"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IPAMReleaseIPMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IPAMReleaseIPMessage_Args& args() const;
  inline ::network_isolator::IPAMReleaseIPMessage_Args* mutable_args();
  inline ::network_isolator::IPAMReleaseIPMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IPAMReleaseIPMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMReleaseIPMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IPAMReleaseIPMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMReleaseIPMessage* default_instance_;
};
// -------------------------------------------------------------------

class IPAMResponse : public ::google::protobuf::Message {
 public:
  IPAMResponse();
  virtual ~IPAMResponse();

  IPAMResponse(const IPAMResponse& from);

  inline IPAMResponse& operator=(const IPAMResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPAMResponse& default_instance();

  void Swap(IPAMResponse* other);

  // implements Message ----------------------------------------------

  IPAMResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPAMResponse& from);
  void MergeFrom(const IPAMResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ipv4 = 1;
  inline int ipv4_size() const;
  inline void clear_ipv4();
  static const int kIpv4FieldNumber = 1;
  inline const ::std::string& ipv4(int index) const;
  inline ::std::string* mutable_ipv4(int index);
  inline void set_ipv4(int index, const ::std::string& value);
  inline void set_ipv4(int index, const char* value);
  inline void set_ipv4(int index, const char* value, size_t size);
  inline ::std::string* add_ipv4();
  inline void add_ipv4(const ::std::string& value);
  inline void add_ipv4(const char* value);
  inline void add_ipv4(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv4() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv4();

  // repeated string ipv6 = 2;
  inline int ipv6_size() const;
  inline void clear_ipv6();
  static const int kIpv6FieldNumber = 2;
  inline const ::std::string& ipv6(int index) const;
  inline ::std::string* mutable_ipv6(int index);
  inline void set_ipv6(int index, const ::std::string& value);
  inline void set_ipv6(int index, const char* value);
  inline void set_ipv6(int index, const char* value, size_t size);
  inline ::std::string* add_ipv6();
  inline void add_ipv6(const ::std::string& value);
  inline void add_ipv6(const char* value);
  inline void add_ipv6(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv6() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv6();

  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:network_isolator.IPAMResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> ipv4_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv6_;
  ::std::string* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IPAMResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorIsolateMessage_Args : public ::google::protobuf::Message {
 public:
  IsolatorIsolateMessage_Args();
  virtual ~IsolatorIsolateMessage_Args();

  IsolatorIsolateMessage_Args(const IsolatorIsolateMessage_Args& from);

  inline IsolatorIsolateMessage_Args& operator=(const IsolatorIsolateMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorIsolateMessage_Args& default_instance();

  void Swap(IsolatorIsolateMessage_Args* other);

  // implements Message ----------------------------------------------

  IsolatorIsolateMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorIsolateMessage_Args& from);
  void MergeFrom(const IsolatorIsolateMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required string container_id = 2;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  inline const ::std::string& container_id() const;
  inline void set_container_id(const ::std::string& value);
  inline void set_container_id(const char* value);
  inline void set_container_id(const char* value, size_t size);
  inline ::std::string* mutable_container_id();
  inline ::std::string* release_container_id();
  inline void set_allocated_container_id(::std::string* container_id);

  // required uint32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);

  // repeated string ipv4_addrs = 4;
  inline int ipv4_addrs_size() const;
  inline void clear_ipv4_addrs();
  static const int kIpv4AddrsFieldNumber = 4;
  inline const ::std::string& ipv4_addrs(int index) const;
  inline ::std::string* mutable_ipv4_addrs(int index);
  inline void set_ipv4_addrs(int index, const ::std::string& value);
  inline void set_ipv4_addrs(int index, const char* value);
  inline void set_ipv4_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv4_addrs();
  inline void add_ipv4_addrs(const ::std::string& value);
  inline void add_ipv4_addrs(const char* value);
  inline void add_ipv4_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv4_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv4_addrs();

  // repeated string ipv6_addrs = 5;
  inline int ipv6_addrs_size() const;
  inline void clear_ipv6_addrs();
  static const int kIpv6AddrsFieldNumber = 5;
  inline const ::std::string& ipv6_addrs(int index) const;
  inline ::std::string* mutable_ipv6_addrs(int index);
  inline void set_ipv6_addrs(int index, const ::std::string& value);
  inline void set_ipv6_addrs(int index, const char* value);
  inline void set_ipv6_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv6_addrs();
  inline void add_ipv6_addrs(const ::std::string& value);
  inline void add_ipv6_addrs(const char* value);
  inline void add_ipv6_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv6_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv6_addrs();

  // repeated string netgroups = 6;
  inline int netgroups_size() const;
  inline void clear_netgroups();
  static const int kNetgroupsFieldNumber = 6;
  inline const ::std::string& netgroups(int index) const;
  inline ::std::string* mutable_netgroups(int index);
  inline void set_netgroups(int index, const ::std::string& value);
  inline void set_netgroups(int index, const char* value);
  inline void set_netgroups(int index, const char* value, size_t size);
  inline ::std::string* add_netgroups();
  inline void add_netgroups(const ::std::string& value);
  inline void add_netgroups(const char* value);
  inline void add_netgroups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& netgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_netgroups();

  // optional .mesos.Labels labels = 7;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 7;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorIsolateMessage.Args)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_id();
  inline void clear_has_container_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* container_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv4_addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv6_addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> netgroups_;
  ::mesos::Labels* labels_;
  ::google::protobuf::uint32 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorIsolateMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorIsolateMessage : public ::google::protobuf::Message {
 public:
  IsolatorIsolateMessage();
  virtual ~IsolatorIsolateMessage();

  IsolatorIsolateMessage(const IsolatorIsolateMessage& from);

  inline IsolatorIsolateMessage& operator=(const IsolatorIsolateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorIsolateMessage& default_instance();

  void Swap(IsolatorIsolateMessage* other);

  // implements Message ----------------------------------------------

  IsolatorIsolateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorIsolateMessage& from);
  void MergeFrom(const IsolatorIsolateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IsolatorIsolateMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "isolate"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IsolatorIsolateMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IsolatorIsolateMessage_Args& args() const;
  inline ::network_isolator::IsolatorIsolateMessage_Args* mutable_args();
  inline ::network_isolator::IsolatorIsolateMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IsolatorIsolateMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorIsolateMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IsolatorIsolateMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorIsolateMessage* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorCleanupMessage_Args : public ::google::protobuf::Message {
 public:
  IsolatorCleanupMessage_Args();
  virtual ~IsolatorCleanupMessage_Args();

  IsolatorCleanupMessage_Args(const IsolatorCleanupMessage_Args& from);

  inline IsolatorCleanupMessage_Args& operator=(const IsolatorCleanupMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorCleanupMessage_Args& default_instance();

  void Swap(IsolatorCleanupMessage_Args* other);

  // implements Message ----------------------------------------------

  IsolatorCleanupMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorCleanupMessage_Args& from);
  void MergeFrom(const IsolatorCleanupMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required string container_id = 2;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  inline const ::std::string& container_id() const;
  inline void set_container_id(const ::std::string& value);
  inline void set_container_id(const char* value);
  inline void set_container_id(const char* value, size_t size);
  inline ::std::string* mutable_container_id();
  inline ::std::string* release_container_id();
  inline void set_allocated_container_id(::std::string* container_id);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorCleanupMessage.Args)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_id();
  inline void clear_has_container_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* container_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorCleanupMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorCleanupMessage : public ::google::protobuf::Message {
 public:
  IsolatorCleanupMessage();
  virtual ~IsolatorCleanupMessage();

  IsolatorCleanupMessage(const IsolatorCleanupMessage& from);

  inline IsolatorCleanupMessage& operator=(const IsolatorCleanupMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorCleanupMessage& default_instance();

  void Swap(IsolatorCleanupMessage* other);

  // implements Message ----------------------------------------------

  IsolatorCleanupMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorCleanupMessage& from);
  void MergeFrom(const IsolatorCleanupMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IsolatorCleanupMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "cleanup"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IsolatorCleanupMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IsolatorCleanupMessage_Args& args() const;
  inline ::network_isolator::IsolatorCleanupMessage_Args* mutable_args();
  inline ::network_isolator::IsolatorCleanupMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IsolatorCleanupMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorCleanupMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IsolatorCleanupMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorCleanupMessage* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorMessage_Args : public ::google::protobuf::Message {
 public:
  IsolatorMessage_Args();
  virtual ~IsolatorMessage_Args();

  IsolatorMessage_Args(const IsolatorMessage_Args& from);

  inline IsolatorMessage_Args& operator=(const IsolatorMessage_Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorMessage_Args& default_instance();

  void Swap(IsolatorMessage_Args* other);

  // implements Message ----------------------------------------------

  IsolatorMessage_Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorMessage_Args& from);
  void MergeFrom(const IsolatorMessage_Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required string container_id = 2;
  inline bool has_container_id() const;
  inline void clear_container_id();
  static const int kContainerIdFieldNumber = 2;
  inline const ::std::string& container_id() const;
  inline void set_container_id(const ::std::string& value);
  inline void set_container_id(const char* value);
  inline void set_container_id(const char* value, size_t size);
  inline ::std::string* mutable_container_id();
  inline ::std::string* release_container_id();
  inline void set_allocated_container_id(::std::string* container_id);

  // required int32 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // repeated string ipv4_addrs = 4;
  inline int ipv4_addrs_size() const;
  inline void clear_ipv4_addrs();
  static const int kIpv4AddrsFieldNumber = 4;
  inline const ::std::string& ipv4_addrs(int index) const;
  inline ::std::string* mutable_ipv4_addrs(int index);
  inline void set_ipv4_addrs(int index, const ::std::string& value);
  inline void set_ipv4_addrs(int index, const char* value);
  inline void set_ipv4_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv4_addrs();
  inline void add_ipv4_addrs(const ::std::string& value);
  inline void add_ipv4_addrs(const char* value);
  inline void add_ipv4_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv4_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv4_addrs();

  // repeated string ipv6_addrs = 5;
  inline int ipv6_addrs_size() const;
  inline void clear_ipv6_addrs();
  static const int kIpv6AddrsFieldNumber = 5;
  inline const ::std::string& ipv6_addrs(int index) const;
  inline ::std::string* mutable_ipv6_addrs(int index);
  inline void set_ipv6_addrs(int index, const ::std::string& value);
  inline void set_ipv6_addrs(int index, const char* value);
  inline void set_ipv6_addrs(int index, const char* value, size_t size);
  inline ::std::string* add_ipv6_addrs();
  inline void add_ipv6_addrs(const ::std::string& value);
  inline void add_ipv6_addrs(const char* value);
  inline void add_ipv6_addrs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ipv6_addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ipv6_addrs();

  // repeated string netgroups = 6;
  inline int netgroups_size() const;
  inline void clear_netgroups();
  static const int kNetgroupsFieldNumber = 6;
  inline const ::std::string& netgroups(int index) const;
  inline ::std::string* mutable_netgroups(int index);
  inline void set_netgroups(int index, const ::std::string& value);
  inline void set_netgroups(int index, const char* value);
  inline void set_netgroups(int index, const char* value, size_t size);
  inline ::std::string* add_netgroups();
  inline void add_netgroups(const ::std::string& value);
  inline void add_netgroups(const char* value);
  inline void add_netgroups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& netgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_netgroups();

  // optional .mesos.Labels labels = 7;
  inline bool has_labels() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 7;
  inline const ::mesos::Labels& labels() const;
  inline ::mesos::Labels* mutable_labels();
  inline ::mesos::Labels* release_labels();
  inline void set_allocated_labels(::mesos::Labels* labels);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorMessage.Args)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_id();
  inline void clear_has_container_id();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_labels();
  inline void clear_has_labels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* container_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv4_addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ipv6_addrs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> netgroups_;
  ::mesos::Labels* labels_;
  ::google::protobuf::int32 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorMessage_Args* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorMessage : public ::google::protobuf::Message {
 public:
  IsolatorMessage();
  virtual ~IsolatorMessage();

  IsolatorMessage(const IsolatorMessage& from);

  inline IsolatorMessage& operator=(const IsolatorMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorMessage& default_instance();

  void Swap(IsolatorMessage* other);

  // implements Message ----------------------------------------------

  IsolatorMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorMessage& from);
  void MergeFrom(const IsolatorMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IsolatorMessage_Args Args;

  // accessors -------------------------------------------------------

  // required string command = 1 [default = "isolate"];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // required .network_isolator.IsolatorMessage.Args args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::network_isolator::IsolatorMessage_Args& args() const;
  inline ::network_isolator::IsolatorMessage_Args* mutable_args();
  inline ::network_isolator::IsolatorMessage_Args* release_args();
  inline void set_allocated_args(::network_isolator::IsolatorMessage_Args* args);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorMessage)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_args();
  inline void clear_has_args();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  static ::std::string* _default_command_;
  ::network_isolator::IsolatorMessage_Args* args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorMessage* default_instance_;
};
// -------------------------------------------------------------------

class IsolatorResponse : public ::google::protobuf::Message {
 public:
  IsolatorResponse();
  virtual ~IsolatorResponse();

  IsolatorResponse(const IsolatorResponse& from);

  inline IsolatorResponse& operator=(const IsolatorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsolatorResponse& default_instance();

  void Swap(IsolatorResponse* other);

  // implements Message ----------------------------------------------

  IsolatorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsolatorResponse& from);
  void MergeFrom(const IsolatorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:network_isolator.IsolatorResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_interface_2eproto();
  friend void protobuf_AssignDesc_interface_2eproto();
  friend void protobuf_ShutdownFile_interface_2eproto();

  void InitAsDefaultInstance();
  static IsolatorResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// IPAMRequestIPMessage_Args

// required string hostname = 1;
inline bool IPAMRequestIPMessage_Args::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPAMRequestIPMessage_Args::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPAMRequestIPMessage_Args::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPAMRequestIPMessage_Args::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IPAMRequestIPMessage_Args::hostname() const {
  return *hostname_;
}
inline void IPAMRequestIPMessage_Args::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMRequestIPMessage_Args::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IPAMRequestIPMessage_Args::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMRequestIPMessage_Args::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 num_ipv4 = 2 [default = 0];
inline bool IPAMRequestIPMessage_Args::has_num_ipv4() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPAMRequestIPMessage_Args::set_has_num_ipv4() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPAMRequestIPMessage_Args::clear_has_num_ipv4() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPAMRequestIPMessage_Args::clear_num_ipv4() {
  num_ipv4_ = 0;
  clear_has_num_ipv4();
}
inline ::google::protobuf::int32 IPAMRequestIPMessage_Args::num_ipv4() const {
  return num_ipv4_;
}
inline void IPAMRequestIPMessage_Args::set_num_ipv4(::google::protobuf::int32 value) {
  set_has_num_ipv4();
  num_ipv4_ = value;
}

// required int32 num_ipv6 = 3 [default = 0];
inline bool IPAMRequestIPMessage_Args::has_num_ipv6() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IPAMRequestIPMessage_Args::set_has_num_ipv6() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IPAMRequestIPMessage_Args::clear_has_num_ipv6() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IPAMRequestIPMessage_Args::clear_num_ipv6() {
  num_ipv6_ = 0;
  clear_has_num_ipv6();
}
inline ::google::protobuf::int32 IPAMRequestIPMessage_Args::num_ipv6() const {
  return num_ipv6_;
}
inline void IPAMRequestIPMessage_Args::set_num_ipv6(::google::protobuf::int32 value) {
  set_has_num_ipv6();
  num_ipv6_ = value;
}

// required string uid = 4;
inline bool IPAMRequestIPMessage_Args::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IPAMRequestIPMessage_Args::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IPAMRequestIPMessage_Args::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IPAMRequestIPMessage_Args::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& IPAMRequestIPMessage_Args::uid() const {
  return *uid_;
}
inline void IPAMRequestIPMessage_Args::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMRequestIPMessage_Args::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* IPAMRequestIPMessage_Args::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMRequestIPMessage_Args::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string netgroups = 5;
inline int IPAMRequestIPMessage_Args::netgroups_size() const {
  return netgroups_.size();
}
inline void IPAMRequestIPMessage_Args::clear_netgroups() {
  netgroups_.Clear();
}
inline const ::std::string& IPAMRequestIPMessage_Args::netgroups(int index) const {
  return netgroups_.Get(index);
}
inline ::std::string* IPAMRequestIPMessage_Args::mutable_netgroups(int index) {
  return netgroups_.Mutable(index);
}
inline void IPAMRequestIPMessage_Args::set_netgroups(int index, const ::std::string& value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_netgroups(int index, const char* value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IPAMRequestIPMessage_Args::set_netgroups(int index, const char* value, size_t size) {
  netgroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMRequestIPMessage_Args::add_netgroups() {
  return netgroups_.Add();
}
inline void IPAMRequestIPMessage_Args::add_netgroups(const ::std::string& value) {
  netgroups_.Add()->assign(value);
}
inline void IPAMRequestIPMessage_Args::add_netgroups(const char* value) {
  netgroups_.Add()->assign(value);
}
inline void IPAMRequestIPMessage_Args::add_netgroups(const char* value, size_t size) {
  netgroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMRequestIPMessage_Args::netgroups() const {
  return netgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMRequestIPMessage_Args::mutable_netgroups() {
  return &netgroups_;
}

// optional .mesos.Labels labels = 6;
inline bool IPAMRequestIPMessage_Args::has_labels() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IPAMRequestIPMessage_Args::set_has_labels() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IPAMRequestIPMessage_Args::clear_has_labels() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IPAMRequestIPMessage_Args::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& IPAMRequestIPMessage_Args::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* IPAMRequestIPMessage_Args::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* IPAMRequestIPMessage_Args::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void IPAMRequestIPMessage_Args::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// -------------------------------------------------------------------

// IPAMRequestIPMessage

// required string command = 1 [default = "allocate"];
inline bool IPAMRequestIPMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPAMRequestIPMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPAMRequestIPMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPAMRequestIPMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IPAMRequestIPMessage::command() const {
  return *command_;
}
inline void IPAMRequestIPMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMRequestIPMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMRequestIPMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMRequestIPMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IPAMRequestIPMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IPAMRequestIPMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IPAMRequestIPMessage.Args args = 2;
inline bool IPAMRequestIPMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPAMRequestIPMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPAMRequestIPMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPAMRequestIPMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IPAMRequestIPMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IPAMRequestIPMessage_Args& IPAMRequestIPMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IPAMRequestIPMessage_Args* IPAMRequestIPMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IPAMRequestIPMessage_Args;
  return args_;
}
inline ::network_isolator::IPAMRequestIPMessage_Args* IPAMRequestIPMessage::release_args() {
  clear_has_args();
  ::network_isolator::IPAMRequestIPMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IPAMRequestIPMessage::set_allocated_args(::network_isolator::IPAMRequestIPMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IPAMReserveIPMessage_Args

// required string hostname = 1;
inline bool IPAMReserveIPMessage_Args::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPAMReserveIPMessage_Args::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPAMReserveIPMessage_Args::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPAMReserveIPMessage_Args::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IPAMReserveIPMessage_Args::hostname() const {
  return *hostname_;
}
inline void IPAMReserveIPMessage_Args::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage_Args::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IPAMReserveIPMessage_Args::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMReserveIPMessage_Args::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string ipv4_addrs = 2;
inline int IPAMReserveIPMessage_Args::ipv4_addrs_size() const {
  return ipv4_addrs_.size();
}
inline void IPAMReserveIPMessage_Args::clear_ipv4_addrs() {
  ipv4_addrs_.Clear();
}
inline const ::std::string& IPAMReserveIPMessage_Args::ipv4_addrs(int index) const {
  return ipv4_addrs_.Get(index);
}
inline ::std::string* IPAMReserveIPMessage_Args::mutable_ipv4_addrs(int index) {
  return ipv4_addrs_.Mutable(index);
}
inline void IPAMReserveIPMessage_Args::set_ipv4_addrs(int index, const ::std::string& value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_ipv4_addrs(int index, const char* value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_ipv4_addrs(int index, const char* value, size_t size) {
  ipv4_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage_Args::add_ipv4_addrs() {
  return ipv4_addrs_.Add();
}
inline void IPAMReserveIPMessage_Args::add_ipv4_addrs(const ::std::string& value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_ipv4_addrs(const char* value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_ipv4_addrs(const char* value, size_t size) {
  ipv4_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMReserveIPMessage_Args::ipv4_addrs() const {
  return ipv4_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMReserveIPMessage_Args::mutable_ipv4_addrs() {
  return &ipv4_addrs_;
}

// repeated string ipv6_addrs = 3;
inline int IPAMReserveIPMessage_Args::ipv6_addrs_size() const {
  return ipv6_addrs_.size();
}
inline void IPAMReserveIPMessage_Args::clear_ipv6_addrs() {
  ipv6_addrs_.Clear();
}
inline const ::std::string& IPAMReserveIPMessage_Args::ipv6_addrs(int index) const {
  return ipv6_addrs_.Get(index);
}
inline ::std::string* IPAMReserveIPMessage_Args::mutable_ipv6_addrs(int index) {
  return ipv6_addrs_.Mutable(index);
}
inline void IPAMReserveIPMessage_Args::set_ipv6_addrs(int index, const ::std::string& value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_ipv6_addrs(int index, const char* value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_ipv6_addrs(int index, const char* value, size_t size) {
  ipv6_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage_Args::add_ipv6_addrs() {
  return ipv6_addrs_.Add();
}
inline void IPAMReserveIPMessage_Args::add_ipv6_addrs(const ::std::string& value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_ipv6_addrs(const char* value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_ipv6_addrs(const char* value, size_t size) {
  ipv6_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMReserveIPMessage_Args::ipv6_addrs() const {
  return ipv6_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMReserveIPMessage_Args::mutable_ipv6_addrs() {
  return &ipv6_addrs_;
}

// required string uid = 4;
inline bool IPAMReserveIPMessage_Args::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IPAMReserveIPMessage_Args::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IPAMReserveIPMessage_Args::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IPAMReserveIPMessage_Args::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& IPAMReserveIPMessage_Args::uid() const {
  return *uid_;
}
inline void IPAMReserveIPMessage_Args::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage_Args::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* IPAMReserveIPMessage_Args::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMReserveIPMessage_Args::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string netgroups = 5;
inline int IPAMReserveIPMessage_Args::netgroups_size() const {
  return netgroups_.size();
}
inline void IPAMReserveIPMessage_Args::clear_netgroups() {
  netgroups_.Clear();
}
inline const ::std::string& IPAMReserveIPMessage_Args::netgroups(int index) const {
  return netgroups_.Get(index);
}
inline ::std::string* IPAMReserveIPMessage_Args::mutable_netgroups(int index) {
  return netgroups_.Mutable(index);
}
inline void IPAMReserveIPMessage_Args::set_netgroups(int index, const ::std::string& value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_netgroups(int index, const char* value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IPAMReserveIPMessage_Args::set_netgroups(int index, const char* value, size_t size) {
  netgroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage_Args::add_netgroups() {
  return netgroups_.Add();
}
inline void IPAMReserveIPMessage_Args::add_netgroups(const ::std::string& value) {
  netgroups_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_netgroups(const char* value) {
  netgroups_.Add()->assign(value);
}
inline void IPAMReserveIPMessage_Args::add_netgroups(const char* value, size_t size) {
  netgroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMReserveIPMessage_Args::netgroups() const {
  return netgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMReserveIPMessage_Args::mutable_netgroups() {
  return &netgroups_;
}

// optional .mesos.Labels labels = 6;
inline bool IPAMReserveIPMessage_Args::has_labels() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IPAMReserveIPMessage_Args::set_has_labels() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IPAMReserveIPMessage_Args::clear_has_labels() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IPAMReserveIPMessage_Args::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& IPAMReserveIPMessage_Args::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* IPAMReserveIPMessage_Args::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* IPAMReserveIPMessage_Args::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void IPAMReserveIPMessage_Args::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// -------------------------------------------------------------------

// IPAMReserveIPMessage

// required string command = 1 [default = "reserve"];
inline bool IPAMReserveIPMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPAMReserveIPMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPAMReserveIPMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPAMReserveIPMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IPAMReserveIPMessage::command() const {
  return *command_;
}
inline void IPAMReserveIPMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMReserveIPMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMReserveIPMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReserveIPMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IPAMReserveIPMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IPAMReserveIPMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IPAMReserveIPMessage.Args args = 2;
inline bool IPAMReserveIPMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPAMReserveIPMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPAMReserveIPMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPAMReserveIPMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IPAMReserveIPMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IPAMReserveIPMessage_Args& IPAMReserveIPMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IPAMReserveIPMessage_Args* IPAMReserveIPMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IPAMReserveIPMessage_Args;
  return args_;
}
inline ::network_isolator::IPAMReserveIPMessage_Args* IPAMReserveIPMessage::release_args() {
  clear_has_args();
  ::network_isolator::IPAMReserveIPMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IPAMReserveIPMessage::set_allocated_args(::network_isolator::IPAMReserveIPMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IPAMReleaseIPMessage_Args

// repeated string ips = 1;
inline int IPAMReleaseIPMessage_Args::ips_size() const {
  return ips_.size();
}
inline void IPAMReleaseIPMessage_Args::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& IPAMReleaseIPMessage_Args::ips(int index) const {
  return ips_.Get(index);
}
inline ::std::string* IPAMReleaseIPMessage_Args::mutable_ips(int index) {
  return ips_.Mutable(index);
}
inline void IPAMReleaseIPMessage_Args::set_ips(int index, const ::std::string& value) {
  ips_.Mutable(index)->assign(value);
}
inline void IPAMReleaseIPMessage_Args::set_ips(int index, const char* value) {
  ips_.Mutable(index)->assign(value);
}
inline void IPAMReleaseIPMessage_Args::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReleaseIPMessage_Args::add_ips() {
  return ips_.Add();
}
inline void IPAMReleaseIPMessage_Args::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
}
inline void IPAMReleaseIPMessage_Args::add_ips(const char* value) {
  ips_.Add()->assign(value);
}
inline void IPAMReleaseIPMessage_Args::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMReleaseIPMessage_Args::ips() const {
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMReleaseIPMessage_Args::mutable_ips() {
  return &ips_;
}

// optional string uid = 2;
inline bool IPAMReleaseIPMessage_Args::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPAMReleaseIPMessage_Args::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPAMReleaseIPMessage_Args::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPAMReleaseIPMessage_Args::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& IPAMReleaseIPMessage_Args::uid() const {
  return *uid_;
}
inline void IPAMReleaseIPMessage_Args::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMReleaseIPMessage_Args::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void IPAMReleaseIPMessage_Args::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReleaseIPMessage_Args::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* IPAMReleaseIPMessage_Args::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMReleaseIPMessage_Args::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IPAMReleaseIPMessage

// required string command = 1 [default = "release"];
inline bool IPAMReleaseIPMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPAMReleaseIPMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPAMReleaseIPMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPAMReleaseIPMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IPAMReleaseIPMessage::command() const {
  return *command_;
}
inline void IPAMReleaseIPMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMReleaseIPMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IPAMReleaseIPMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMReleaseIPMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IPAMReleaseIPMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IPAMReleaseIPMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IPAMReleaseIPMessage.Args args = 2;
inline bool IPAMReleaseIPMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPAMReleaseIPMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPAMReleaseIPMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPAMReleaseIPMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IPAMReleaseIPMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IPAMReleaseIPMessage_Args& IPAMReleaseIPMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IPAMReleaseIPMessage_Args* IPAMReleaseIPMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IPAMReleaseIPMessage_Args;
  return args_;
}
inline ::network_isolator::IPAMReleaseIPMessage_Args* IPAMReleaseIPMessage::release_args() {
  clear_has_args();
  ::network_isolator::IPAMReleaseIPMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IPAMReleaseIPMessage::set_allocated_args(::network_isolator::IPAMReleaseIPMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IPAMResponse

// repeated string ipv4 = 1;
inline int IPAMResponse::ipv4_size() const {
  return ipv4_.size();
}
inline void IPAMResponse::clear_ipv4() {
  ipv4_.Clear();
}
inline const ::std::string& IPAMResponse::ipv4(int index) const {
  return ipv4_.Get(index);
}
inline ::std::string* IPAMResponse::mutable_ipv4(int index) {
  return ipv4_.Mutable(index);
}
inline void IPAMResponse::set_ipv4(int index, const ::std::string& value) {
  ipv4_.Mutable(index)->assign(value);
}
inline void IPAMResponse::set_ipv4(int index, const char* value) {
  ipv4_.Mutable(index)->assign(value);
}
inline void IPAMResponse::set_ipv4(int index, const char* value, size_t size) {
  ipv4_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMResponse::add_ipv4() {
  return ipv4_.Add();
}
inline void IPAMResponse::add_ipv4(const ::std::string& value) {
  ipv4_.Add()->assign(value);
}
inline void IPAMResponse::add_ipv4(const char* value) {
  ipv4_.Add()->assign(value);
}
inline void IPAMResponse::add_ipv4(const char* value, size_t size) {
  ipv4_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMResponse::ipv4() const {
  return ipv4_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMResponse::mutable_ipv4() {
  return &ipv4_;
}

// repeated string ipv6 = 2;
inline int IPAMResponse::ipv6_size() const {
  return ipv6_.size();
}
inline void IPAMResponse::clear_ipv6() {
  ipv6_.Clear();
}
inline const ::std::string& IPAMResponse::ipv6(int index) const {
  return ipv6_.Get(index);
}
inline ::std::string* IPAMResponse::mutable_ipv6(int index) {
  return ipv6_.Mutable(index);
}
inline void IPAMResponse::set_ipv6(int index, const ::std::string& value) {
  ipv6_.Mutable(index)->assign(value);
}
inline void IPAMResponse::set_ipv6(int index, const char* value) {
  ipv6_.Mutable(index)->assign(value);
}
inline void IPAMResponse::set_ipv6(int index, const char* value, size_t size) {
  ipv6_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMResponse::add_ipv6() {
  return ipv6_.Add();
}
inline void IPAMResponse::add_ipv6(const ::std::string& value) {
  ipv6_.Add()->assign(value);
}
inline void IPAMResponse::add_ipv6(const char* value) {
  ipv6_.Add()->assign(value);
}
inline void IPAMResponse::add_ipv6(const char* value, size_t size) {
  ipv6_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IPAMResponse::ipv6() const {
  return ipv6_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IPAMResponse::mutable_ipv6() {
  return &ipv6_;
}

// optional string error = 3;
inline bool IPAMResponse::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IPAMResponse::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IPAMResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IPAMResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& IPAMResponse::error() const {
  return *error_;
}
inline void IPAMResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void IPAMResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void IPAMResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IPAMResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* IPAMResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IPAMResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IsolatorIsolateMessage_Args

// required string hostname = 1;
inline bool IsolatorIsolateMessage_Args::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorIsolateMessage_Args::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorIsolateMessage_Args::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorIsolateMessage_Args::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IsolatorIsolateMessage_Args::hostname() const {
  return *hostname_;
}
inline void IsolatorIsolateMessage_Args::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage_Args::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IsolatorIsolateMessage_Args::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorIsolateMessage_Args::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string container_id = 2;
inline bool IsolatorIsolateMessage_Args::has_container_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorIsolateMessage_Args::set_has_container_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorIsolateMessage_Args::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorIsolateMessage_Args::clear_container_id() {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    container_id_->clear();
  }
  clear_has_container_id();
}
inline const ::std::string& IsolatorIsolateMessage_Args::container_id() const {
  return *container_id_;
}
inline void IsolatorIsolateMessage_Args::set_container_id(const ::std::string& value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_container_id(const char* value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage_Args::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  return container_id_;
}
inline ::std::string* IsolatorIsolateMessage_Args::release_container_id() {
  clear_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_id_;
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorIsolateMessage_Args::set_allocated_container_id(::std::string* container_id) {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    delete container_id_;
  }
  if (container_id) {
    set_has_container_id();
    container_id_ = container_id;
  } else {
    clear_has_container_id();
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 pid = 3;
inline bool IsolatorIsolateMessage_Args::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IsolatorIsolateMessage_Args::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IsolatorIsolateMessage_Args::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IsolatorIsolateMessage_Args::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 IsolatorIsolateMessage_Args::pid() const {
  return pid_;
}
inline void IsolatorIsolateMessage_Args::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// repeated string ipv4_addrs = 4;
inline int IsolatorIsolateMessage_Args::ipv4_addrs_size() const {
  return ipv4_addrs_.size();
}
inline void IsolatorIsolateMessage_Args::clear_ipv4_addrs() {
  ipv4_addrs_.Clear();
}
inline const ::std::string& IsolatorIsolateMessage_Args::ipv4_addrs(int index) const {
  return ipv4_addrs_.Get(index);
}
inline ::std::string* IsolatorIsolateMessage_Args::mutable_ipv4_addrs(int index) {
  return ipv4_addrs_.Mutable(index);
}
inline void IsolatorIsolateMessage_Args::set_ipv4_addrs(int index, const ::std::string& value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_ipv4_addrs(int index, const char* value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_ipv4_addrs(int index, const char* value, size_t size) {
  ipv4_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage_Args::add_ipv4_addrs() {
  return ipv4_addrs_.Add();
}
inline void IsolatorIsolateMessage_Args::add_ipv4_addrs(const ::std::string& value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_ipv4_addrs(const char* value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_ipv4_addrs(const char* value, size_t size) {
  ipv4_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorIsolateMessage_Args::ipv4_addrs() const {
  return ipv4_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorIsolateMessage_Args::mutable_ipv4_addrs() {
  return &ipv4_addrs_;
}

// repeated string ipv6_addrs = 5;
inline int IsolatorIsolateMessage_Args::ipv6_addrs_size() const {
  return ipv6_addrs_.size();
}
inline void IsolatorIsolateMessage_Args::clear_ipv6_addrs() {
  ipv6_addrs_.Clear();
}
inline const ::std::string& IsolatorIsolateMessage_Args::ipv6_addrs(int index) const {
  return ipv6_addrs_.Get(index);
}
inline ::std::string* IsolatorIsolateMessage_Args::mutable_ipv6_addrs(int index) {
  return ipv6_addrs_.Mutable(index);
}
inline void IsolatorIsolateMessage_Args::set_ipv6_addrs(int index, const ::std::string& value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_ipv6_addrs(int index, const char* value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_ipv6_addrs(int index, const char* value, size_t size) {
  ipv6_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage_Args::add_ipv6_addrs() {
  return ipv6_addrs_.Add();
}
inline void IsolatorIsolateMessage_Args::add_ipv6_addrs(const ::std::string& value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_ipv6_addrs(const char* value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_ipv6_addrs(const char* value, size_t size) {
  ipv6_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorIsolateMessage_Args::ipv6_addrs() const {
  return ipv6_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorIsolateMessage_Args::mutable_ipv6_addrs() {
  return &ipv6_addrs_;
}

// repeated string netgroups = 6;
inline int IsolatorIsolateMessage_Args::netgroups_size() const {
  return netgroups_.size();
}
inline void IsolatorIsolateMessage_Args::clear_netgroups() {
  netgroups_.Clear();
}
inline const ::std::string& IsolatorIsolateMessage_Args::netgroups(int index) const {
  return netgroups_.Get(index);
}
inline ::std::string* IsolatorIsolateMessage_Args::mutable_netgroups(int index) {
  return netgroups_.Mutable(index);
}
inline void IsolatorIsolateMessage_Args::set_netgroups(int index, const ::std::string& value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_netgroups(int index, const char* value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IsolatorIsolateMessage_Args::set_netgroups(int index, const char* value, size_t size) {
  netgroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage_Args::add_netgroups() {
  return netgroups_.Add();
}
inline void IsolatorIsolateMessage_Args::add_netgroups(const ::std::string& value) {
  netgroups_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_netgroups(const char* value) {
  netgroups_.Add()->assign(value);
}
inline void IsolatorIsolateMessage_Args::add_netgroups(const char* value, size_t size) {
  netgroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorIsolateMessage_Args::netgroups() const {
  return netgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorIsolateMessage_Args::mutable_netgroups() {
  return &netgroups_;
}

// optional .mesos.Labels labels = 7;
inline bool IsolatorIsolateMessage_Args::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IsolatorIsolateMessage_Args::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IsolatorIsolateMessage_Args::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IsolatorIsolateMessage_Args::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& IsolatorIsolateMessage_Args::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* IsolatorIsolateMessage_Args::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* IsolatorIsolateMessage_Args::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void IsolatorIsolateMessage_Args::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// -------------------------------------------------------------------

// IsolatorIsolateMessage

// required string command = 1 [default = "isolate"];
inline bool IsolatorIsolateMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorIsolateMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorIsolateMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorIsolateMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IsolatorIsolateMessage::command() const {
  return *command_;
}
inline void IsolatorIsolateMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorIsolateMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorIsolateMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorIsolateMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IsolatorIsolateMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IsolatorIsolateMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IsolatorIsolateMessage.Args args = 2;
inline bool IsolatorIsolateMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorIsolateMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorIsolateMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorIsolateMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IsolatorIsolateMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IsolatorIsolateMessage_Args& IsolatorIsolateMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IsolatorIsolateMessage_Args* IsolatorIsolateMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IsolatorIsolateMessage_Args;
  return args_;
}
inline ::network_isolator::IsolatorIsolateMessage_Args* IsolatorIsolateMessage::release_args() {
  clear_has_args();
  ::network_isolator::IsolatorIsolateMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IsolatorIsolateMessage::set_allocated_args(::network_isolator::IsolatorIsolateMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IsolatorCleanupMessage_Args

// required string hostname = 1;
inline bool IsolatorCleanupMessage_Args::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorCleanupMessage_Args::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorCleanupMessage_Args::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorCleanupMessage_Args::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IsolatorCleanupMessage_Args::hostname() const {
  return *hostname_;
}
inline void IsolatorCleanupMessage_Args::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorCleanupMessage_Args::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorCleanupMessage_Args::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorCleanupMessage_Args::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IsolatorCleanupMessage_Args::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorCleanupMessage_Args::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string container_id = 2;
inline bool IsolatorCleanupMessage_Args::has_container_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorCleanupMessage_Args::set_has_container_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorCleanupMessage_Args::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorCleanupMessage_Args::clear_container_id() {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    container_id_->clear();
  }
  clear_has_container_id();
}
inline const ::std::string& IsolatorCleanupMessage_Args::container_id() const {
  return *container_id_;
}
inline void IsolatorCleanupMessage_Args::set_container_id(const ::std::string& value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorCleanupMessage_Args::set_container_id(const char* value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorCleanupMessage_Args::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorCleanupMessage_Args::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  return container_id_;
}
inline ::std::string* IsolatorCleanupMessage_Args::release_container_id() {
  clear_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_id_;
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorCleanupMessage_Args::set_allocated_container_id(::std::string* container_id) {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    delete container_id_;
  }
  if (container_id) {
    set_has_container_id();
    container_id_ = container_id;
  } else {
    clear_has_container_id();
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IsolatorCleanupMessage

// required string command = 1 [default = "cleanup"];
inline bool IsolatorCleanupMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorCleanupMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorCleanupMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorCleanupMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IsolatorCleanupMessage::command() const {
  return *command_;
}
inline void IsolatorCleanupMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorCleanupMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorCleanupMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorCleanupMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IsolatorCleanupMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IsolatorCleanupMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IsolatorCleanupMessage.Args args = 2;
inline bool IsolatorCleanupMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorCleanupMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorCleanupMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorCleanupMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IsolatorCleanupMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IsolatorCleanupMessage_Args& IsolatorCleanupMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IsolatorCleanupMessage_Args* IsolatorCleanupMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IsolatorCleanupMessage_Args;
  return args_;
}
inline ::network_isolator::IsolatorCleanupMessage_Args* IsolatorCleanupMessage::release_args() {
  clear_has_args();
  ::network_isolator::IsolatorCleanupMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IsolatorCleanupMessage::set_allocated_args(::network_isolator::IsolatorCleanupMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IsolatorMessage_Args

// required string hostname = 1;
inline bool IsolatorMessage_Args::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorMessage_Args::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorMessage_Args::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorMessage_Args::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& IsolatorMessage_Args::hostname() const {
  return *hostname_;
}
inline void IsolatorMessage_Args::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorMessage_Args::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void IsolatorMessage_Args::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage_Args::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* IsolatorMessage_Args::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorMessage_Args::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string container_id = 2;
inline bool IsolatorMessage_Args::has_container_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorMessage_Args::set_has_container_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorMessage_Args::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorMessage_Args::clear_container_id() {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    container_id_->clear();
  }
  clear_has_container_id();
}
inline const ::std::string& IsolatorMessage_Args::container_id() const {
  return *container_id_;
}
inline void IsolatorMessage_Args::set_container_id(const ::std::string& value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorMessage_Args::set_container_id(const char* value) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(value);
}
inline void IsolatorMessage_Args::set_container_id(const char* value, size_t size) {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  container_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage_Args::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    container_id_ = new ::std::string;
  }
  return container_id_;
}
inline ::std::string* IsolatorMessage_Args::release_container_id() {
  clear_has_container_id();
  if (container_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_id_;
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorMessage_Args::set_allocated_container_id(::std::string* container_id) {
  if (container_id_ != &::google::protobuf::internal::kEmptyString) {
    delete container_id_;
  }
  if (container_id) {
    set_has_container_id();
    container_id_ = container_id;
  } else {
    clear_has_container_id();
    container_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 pid = 3;
inline bool IsolatorMessage_Args::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IsolatorMessage_Args::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IsolatorMessage_Args::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IsolatorMessage_Args::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 IsolatorMessage_Args::pid() const {
  return pid_;
}
inline void IsolatorMessage_Args::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
}

// repeated string ipv4_addrs = 4;
inline int IsolatorMessage_Args::ipv4_addrs_size() const {
  return ipv4_addrs_.size();
}
inline void IsolatorMessage_Args::clear_ipv4_addrs() {
  ipv4_addrs_.Clear();
}
inline const ::std::string& IsolatorMessage_Args::ipv4_addrs(int index) const {
  return ipv4_addrs_.Get(index);
}
inline ::std::string* IsolatorMessage_Args::mutable_ipv4_addrs(int index) {
  return ipv4_addrs_.Mutable(index);
}
inline void IsolatorMessage_Args::set_ipv4_addrs(int index, const ::std::string& value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_ipv4_addrs(int index, const char* value) {
  ipv4_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_ipv4_addrs(int index, const char* value, size_t size) {
  ipv4_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage_Args::add_ipv4_addrs() {
  return ipv4_addrs_.Add();
}
inline void IsolatorMessage_Args::add_ipv4_addrs(const ::std::string& value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_ipv4_addrs(const char* value) {
  ipv4_addrs_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_ipv4_addrs(const char* value, size_t size) {
  ipv4_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorMessage_Args::ipv4_addrs() const {
  return ipv4_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorMessage_Args::mutable_ipv4_addrs() {
  return &ipv4_addrs_;
}

// repeated string ipv6_addrs = 5;
inline int IsolatorMessage_Args::ipv6_addrs_size() const {
  return ipv6_addrs_.size();
}
inline void IsolatorMessage_Args::clear_ipv6_addrs() {
  ipv6_addrs_.Clear();
}
inline const ::std::string& IsolatorMessage_Args::ipv6_addrs(int index) const {
  return ipv6_addrs_.Get(index);
}
inline ::std::string* IsolatorMessage_Args::mutable_ipv6_addrs(int index) {
  return ipv6_addrs_.Mutable(index);
}
inline void IsolatorMessage_Args::set_ipv6_addrs(int index, const ::std::string& value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_ipv6_addrs(int index, const char* value) {
  ipv6_addrs_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_ipv6_addrs(int index, const char* value, size_t size) {
  ipv6_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage_Args::add_ipv6_addrs() {
  return ipv6_addrs_.Add();
}
inline void IsolatorMessage_Args::add_ipv6_addrs(const ::std::string& value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_ipv6_addrs(const char* value) {
  ipv6_addrs_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_ipv6_addrs(const char* value, size_t size) {
  ipv6_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorMessage_Args::ipv6_addrs() const {
  return ipv6_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorMessage_Args::mutable_ipv6_addrs() {
  return &ipv6_addrs_;
}

// repeated string netgroups = 6;
inline int IsolatorMessage_Args::netgroups_size() const {
  return netgroups_.size();
}
inline void IsolatorMessage_Args::clear_netgroups() {
  netgroups_.Clear();
}
inline const ::std::string& IsolatorMessage_Args::netgroups(int index) const {
  return netgroups_.Get(index);
}
inline ::std::string* IsolatorMessage_Args::mutable_netgroups(int index) {
  return netgroups_.Mutable(index);
}
inline void IsolatorMessage_Args::set_netgroups(int index, const ::std::string& value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_netgroups(int index, const char* value) {
  netgroups_.Mutable(index)->assign(value);
}
inline void IsolatorMessage_Args::set_netgroups(int index, const char* value, size_t size) {
  netgroups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage_Args::add_netgroups() {
  return netgroups_.Add();
}
inline void IsolatorMessage_Args::add_netgroups(const ::std::string& value) {
  netgroups_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_netgroups(const char* value) {
  netgroups_.Add()->assign(value);
}
inline void IsolatorMessage_Args::add_netgroups(const char* value, size_t size) {
  netgroups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IsolatorMessage_Args::netgroups() const {
  return netgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IsolatorMessage_Args::mutable_netgroups() {
  return &netgroups_;
}

// optional .mesos.Labels labels = 7;
inline bool IsolatorMessage_Args::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IsolatorMessage_Args::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IsolatorMessage_Args::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IsolatorMessage_Args::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
inline const ::mesos::Labels& IsolatorMessage_Args::labels() const {
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
inline ::mesos::Labels* IsolatorMessage_Args::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) labels_ = new ::mesos::Labels;
  return labels_;
}
inline ::mesos::Labels* IsolatorMessage_Args::release_labels() {
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
inline void IsolatorMessage_Args::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
}

// -------------------------------------------------------------------

// IsolatorMessage

// required string command = 1 [default = "isolate"];
inline bool IsolatorMessage::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorMessage::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorMessage::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorMessage::clear_command() {
  if (command_ != _default_command_) {
    command_->assign(*_default_command_);
  }
  clear_has_command();
}
inline const ::std::string& IsolatorMessage::command() const {
  return *command_;
}
inline void IsolatorMessage::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorMessage::set_command(const char* value) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void IsolatorMessage::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorMessage::mutable_command() {
  set_has_command();
  if (command_ == _default_command_) {
    command_ = new ::std::string(*_default_command_);
  }
  return command_;
}
inline ::std::string* IsolatorMessage::release_command() {
  clear_has_command();
  if (command_ == _default_command_) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(_default_command_);
    return temp;
  }
}
inline void IsolatorMessage::set_allocated_command(::std::string* command) {
  if (command_ != _default_command_) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(_default_command_);
  }
}

// required .network_isolator.IsolatorMessage.Args args = 2;
inline bool IsolatorMessage::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsolatorMessage::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsolatorMessage::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsolatorMessage::clear_args() {
  if (args_ != NULL) args_->::network_isolator::IsolatorMessage_Args::Clear();
  clear_has_args();
}
inline const ::network_isolator::IsolatorMessage_Args& IsolatorMessage::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::network_isolator::IsolatorMessage_Args* IsolatorMessage::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::network_isolator::IsolatorMessage_Args;
  return args_;
}
inline ::network_isolator::IsolatorMessage_Args* IsolatorMessage::release_args() {
  clear_has_args();
  ::network_isolator::IsolatorMessage_Args* temp = args_;
  args_ = NULL;
  return temp;
}
inline void IsolatorMessage::set_allocated_args(::network_isolator::IsolatorMessage_Args* args) {
  delete args_;
  args_ = args;
  if (args) {
    set_has_args();
  } else {
    clear_has_args();
  }
}

// -------------------------------------------------------------------

// IsolatorResponse

// optional string error = 1;
inline bool IsolatorResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsolatorResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsolatorResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsolatorResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& IsolatorResponse::error() const {
  return *error_;
}
inline void IsolatorResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void IsolatorResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void IsolatorResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IsolatorResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* IsolatorResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IsolatorResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace network_isolator

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_interface_2eproto__INCLUDED
